Possible ticket file format:

   "Ticket"
   title: TEXT
   ticketid: TEXT
   exists-in: BASELINE   -- 0 or more
   fixed-in: BASELINE    -- 0 or more
   tag: TAG              -- 0 or more
   created: DATETIME
   attachment: FILENAME DESCRIPTION
   parent: UUID*
   derived-from: TICKET-FILENAME
   description: MULTILINE-TEXT
   remarks: MULTILINE-TEXT

   * Things handles with tags:
     created-by
     assigned-to
     priority
     severity
     target-release
     status
     resolution
     type
     subsystem

Wiki header format:
   "WikiPage"
   parent: UUID*
   title: TEXT
   pagename: TEXT
   mode: (readonly|appendonly|readwrite)
   attachment: UUID name description

   * Header ends with a blank line.  wiki content follows.

Cluster format:

       M+ uuid
       Z manifest-cksum

   * Cluster generated in server mode only.
   * Embargo cluster that reference phantoms or other embargoed clusters.
   * Never send or ihave an embargoed cluster

New sync algorithm based on clusters:

   * Keep a table of unclustered artifacts.  Strive to keep this table
     less than 100 entries.
   * Client sends content of unclustered table as ihaves to server
   * Server builds a new cluster if size of cluster table >100.
   * Server sends unclustered table to client
   * Server sends gimme for all unknown ihave received from client
   * Client sends gimme for all unknown ihave received from server
   * Previous two steps repeat until no more gimmes

Details of new push algorithm:

   * Table "unsent" contains all files never pushed
   * TEMP table "wanted" contains files the server does not have
   Loop:
     * Client sends login and "push" record
     * Client sends file message for all files in unsent and removes
       those files from the table.
     * Client sends file message for all files in wanted.
     * Client sends ihave messages for each entry in unclustered
     ------
     * Server receives file message
     * Server creates phantoms for unknown ihaves
     * Server sends gimme messages for all phantoms
     ------
     * Client clears its unsent table
     * For each gimme message add an entry to wanted
     * Halt if the wanted table is empty

Details on new pull algorithm:

   Loop:
     * Client sends login and "pull" record
     * Client sends "prior" message with repository id and max record number
     * Client sends "gimme" for each phantom
     --------
     * Server creates new clusters to get unclustered size below 100
     * If there is "prior" message with repository id that matches this
       server, then send file messages for all record ids greater than
       prior
     * Server sends ihave messages for each entry in unclustered
     * Server sends maxrid message
     --------
     * Client receives file records
     * Client creates phantoms for unknown ihaves
     * If no phantoms exist, record maxrid for the server and halt

Need a dephantomize algorithm


Auxiliary tables needed for new sync algorithm:

   * unsent:  files that have never been sent to another repository
   * unclustered: non-phantom files not mentioned by a cluster

Random thoughts:

  *  Changes to manifest to support:
     +  Trees of wiki pages and tickets
     +  The ability to cap or close a branch
     +  See "Extended Manifests" below

  *  Add the concept of "clusters" to speed the transfer of "tips"
     on a sync.

  *  Auxiliary tables:
     +  tip
     +  phantom
     +  mlink
     +  plink
     +  branch
     +  tree

  * Plink.isprim changed to record:
     +  child is the principal descendent of parent. (1)
     +  child is a branch from parent (2)
     +  child uses parent as a merge (0)

  * tree records
     + type  (code, wiki, ticket)
     + name  (for wiki and ticket only)
     + treeid

  * branch records
     + treeid
     + origin_rid
     + origin_time
     + tip_rid
     + tip_time
     + color

  * website can toggle isprim between principal and branch.
     + How to preserve across rebuild.  A new record type?
     + How to share with other repositories
  * isprim guessed using userid of parent and child.  Change
    in id suggests a branch.  Same id suggests principal.
    For a tie, go with the earliest check-in as the principal'

  * Autosync mode
     + Set a preferred remote repository to use as a server
        =  Clone repository is the default
     + On commit, first pull.  If commit baseline is not a tip
       prompt user to cancel or branch.  Default is cancel.
     + Push after commit
     + Automatically pull prior to update.
     + Need an "undo" capability
     + Designed to avoid branching in highly collaborative 
       environments.

  * Archeological webpage improvements:
     + Use a small amount of CSS+javascript on timelines so that
       branching structure is displayed on mouseover.  On mouseover
       of a checkin, highlight other checkins that are direct (non-merge)
       descendents and ancestors of the mouseover checkin.
     + Timeline showing individual branches
     + Timeline shows forks and merges
     + Tags shown on timeline (maybe) and in vinfo (surely).

Features needed:
  * Means to suppress artifacts
  * Means to cap a branch
  * Ticketing
     +  Problem is/is-not expressed in baseline X.
     +  Append comment and zero or more attachments
  * Modify comments on baselines
  * Append comments to any artifact
  * Wiki?

  

Extended manifests.
  * normal manifest has:
       C comment
       D date-time
       F* filename uuid
       P uuid ...           -- omitted for first manifest
       R repository-md5sum
       U user-login
       Z manifest-checksum

  * Accessory:
       A uuid|* attachment-uuid description
       D date-time
       E uuid new-comment
       G uuid appended-remark
       S repositoryid serial-number
       T (+|-)tag uuid
       U userid
       X uuid-to-surpress
       Z this-file-checksum

  * Change the comment on a version:   -- always a leaf except in cluster
       D date-time
       E new-comment
       P uuid              -- baseline whose comment is changed
       U user-login
       Z checksum
       -- most recent wins
  * Wiki edit
       A* name uuid   -- zero or more attachments
       C? comment
       D date-time
       N name         -- name of the wiki page
       P uuid ...     -- omit for new wiki
       U user-login
       W uuid         -- The content file
       Z manifest-cksum
  * Ticket edit
       A* name uuid   -- zero or more attachments
       D date-time
       N name         -- name of the ticket
       P uuid         -- omit for new ticket
       T uuid         -- content of the ticket
       U user-login
       Z manifest-cksum
  * Set or erase a tag    -- most recent date wins
       B* (+|-)tag uuid
       C? comment
       D date-time
       V* (+|-) tag uuid    -- + to set, - to clear.  
       Z manifest-cksum
       -- Must have at least one B or V.
       -- Branch tag "hidden" means do not sync
       -- Version tag "closed" means do not display as a leaf
  * A cluster
       M+ uuid
       Z manifest-cksum

  * Complete set of cards in a control file:
       A filename uuid             
       B (+|-)branch-tag uuid      
       C comment                   
       D date-time                 
       E uuid edited-comment       
       F filename uuid             
       M uuid                      
       N name                      
       P uuid ...                  
       R repository-md5sum         
       T uuid                      
       U user-login                
       V (+|-)version-tag uuid     
       W uuid                      
       Z manifest-checksum         
