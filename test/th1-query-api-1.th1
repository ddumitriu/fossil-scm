This is not a formal test suite, but a tinkering ground.
Run it through "fossil test-th-render THIS_FILE".
<th1>
set stmt [query prepare {SELECT login, cap FROM user}]
set colCount [query $stmt col count]
puts "query column count: ${colCount}\n"
puts "stmt id=${stmt}\n"

proc noop {} {}
proc incr {name {step 1}} {
    upvar $name x
    set x [expr $x+$step]
}


set sep "    "
set i 0
set colNames(0) 0
for {set i 0} {$i < $colCount} {incr i} {
    set colNames($i) [query $stmt col name $i]
    puts "colNames($i)=" $colNames($i) "\n"
}

for {set row 0} {[query $stmt step]} {incr row} {
    for {set i 0} {$i < $colCount} {incr i} {
        if {$i > 0} {
            puts $sep
        } else {
            puts "#$row: $sep"
        }
        puts $colNames($i) = [query $stmt col string $i]
    }
    puts "\n"
}
unset row

query $stmt finalize
#query finalize $stmt 


proc query_step_each {{stmt} {callback}} {
    set colNames(0) 0
    set colCount [query $stmt col count]
    for {set i 0} {$i < $colCount} {incr i} {
        set colNames($i) [query $stmt col name $i]
    }
    upvar cb $callback
    for {set row 0} {[query $stmt step]} {incr row} {
        #puts "Calling callback: $stmt $colCount colNames\n"
        $callback $stmt $colCount
    }
}

set sql {SELECT uid, login FROM user WHERE uid!=?}
#set sql {SELECT uid, login FROM user WHERE login=?}
#set sql {SELECT tagid, value, null FROM tagxref WHERE value IS ? LIMIT 3}
set stmt [query prepare $sql]
puts "stmt ID=" $stmt "\n"
#query bind int $stmt 1 3
#query $stmt bind 1 int 3
query $stmt bind 1 string 3
#query $stmt bind string 1 3
#set stmt [query prepare $sql]
#query $stmt bind 1 string 1
#set stmt [query prepare $sql]
#query $stmt bind null 1
puts "USER LIST:\n"
catch {
    proc my_each {stmt colCount} {
        upvar 2 sep sep
        puts [query $stmt col int 0] " (type=" [query $stmt col type 0] ")" $sep
        puts [query $stmt col double 0] $sep
        puts [query $stmt col string 1]  " (type=" [query $stmt col type 1] ")" $sep
        puts "isnull 0 ?= " [query $stmt col is_null 0] $sep
        puts "isnull 2 ?= " [query col is_null $stmt 2]
#        for {set i 0} {$i < $colCount} {incr i} {
#            if {$i > 0} { puts $sep }
#        }
        puts "\n"
#        error "hi!"
    }
    query_step_each $stmt my_each
#    query reset $stmt
#    query $stmt reset 
#    query_step_each $stmt {
#        proc each {stmt cc} { puts hi "\n" }
#    }
    return 0
} rc
query finalize $stmt
if { 0 != $rc } {
        puts "ERROR: $rc\n"
}

set consts [list SQLITE_BLOB SQLITE_FLOAT SQLITE_INTEGER SQLITE_NULL SQLITE_TEXT]
#set consts $SQLITE_CONSTANTS
puts consts = $consts "\n"
for {set i 0} {$i < [llength $consts]} {incr i} {
    set x [lindex $consts $i]
    puts \$$x = [expr \$$x] "\n"
}

set ARGC [argv len]
puts ARGC = $ARGC "\n"
for {set i 0} {$i < $ARGC} {incr i} {
    puts "argv at $i = " [argv at $i] \n
}

set magicDefault hi
set optA [argv string AA a $magicDefault]
puts "argv string AA = " $optA \n

set optA [argv bool BB b 0]
puts "argv bool BB = " $optA \n

set exception 0
catch {
    argv int noSuchOptionAndNoDefault
} exception
puts exception = $exception "\n"

proc multiStmt {} {
    set max 5
    set i 0
    set s(0) 0
    for {set i 0} {$i < $max} {incr i} {
       set s($i) [query prepare "SELECT $i"]
       puts "s($i) = $s($i)\n"
    }
    for {set i 0} {$i < $max} {incr i} {
       query $s($i) step
    }
    for {set i 0} {$i < $max} {incr i} {
       puts "closing stmt $s($i)\n"
       query $s($i) finalize
    }

    puts "Preparing again\n"

    for {set i 0} {$i < $max} {incr i} {
       set s($i) [query prepare "SELECT $i"]
       puts "s($i) = $s($i)\n"
    }
    for {set i 0} {$i < $max} {incr i} {
       query $s($i) step
    }
    puts "Closing again\n"

    for {set i 0} {$i < $max} {incr i} {
       puts "closing stmt $s($i)\n"
       query $s($i) finalize
    }
}
multiStmt

puts "If you got this far, you win!\n"
</th1>
