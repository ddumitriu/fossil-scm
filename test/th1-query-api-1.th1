This is not a formal test suite, but a tinkering ground.
Run it through "fossil test-th-render THIS_FILE".
<th1>
proc bar {} {
puts "json ?= [hasfeature json]\n"
puts "tcl ?= [hasfeature tcl]\n"
puts "ssl ?= [hasfeature ssl]\n"
puts [lindex {a b c} 1] "\n"
proc foo {a {b steve}} {
        puts "a = ${a}\n"
        puts "b = ${b}\n"
}
foo hi world
foo hi {string list}
# foo
puts a b c foo \n
}
bar
foo leaky

proc xyz {} {
        return 42
}
set a [xyz]
puts "a=${a}" ! \n

set stmt [query_prepare {SELECT login, cap FROM user}]
set colCount [query_col_count $stmt]
puts "query column count: ${colCount}\n"
#set stmt2 [query_prepare {SELECT cap, login FROM user}]
#puts "stmt=${stmt} stmt2=${stmt2}\n"
#putsl "step =" [query_step $stmt]
#putsl "cap =" [query_col_string $stmt 1]

proc noop {} {}
proc incr {name {step 1}} {
    upvar $name x
    set x [expr $x+$step]
}


set sep "    "
set i 0
set colNames(0) 0
for {set i 0} {$i < $colCount} {incr i} {
    set colNames($i) [query_col_name $stmt $i]
    puts "colNames($i)=" $colNames($i) "\n"
}

for {set row 0} {0 < [query_step $stmt]} {incr row} {
    for {set i 0} {$i < $colCount} {incr i} {
        if {$i > 0} {
            puts $sep
        } else {
            puts "#$row: $sep"
        }
        puts $colNames($i) = [query_col_string $stmt $i]
    }
    puts "\n"
}
unset row

query_finalize $stmt
#query_finalize $stmt2


proc query_step_each {{stmt} {callback}} {
    set colNames(0) 0
    set colCount [query_col_count $stmt]
    for {set i 0} {$i < $colCount} {incr i} {
        set colNames($i) [query_col_name $stmt $i]
    }
    upvar cb $callback
    for {set row 0} {0 < [query_step $stmt]} {incr row} {
        #puts "Calling callback: $stmt $colCount colNames\n"
        $callback $stmt $colCount
    }
}

set sql {SELECT uid, login FROM user WHERE uid!=?}
#set sql {SELECT uid, login FROM user WHERE login=?}
#set sql {SELECT tagid, value, null FROM tagxref WHERE value IS ? LIMIT 3}
set stmt [query_prepare $sql]
puts "stmt ID=" $stmt "\n"
query_bind_int $stmt 1 3
#set stmt [query_prepare $sql]
#query_bind_string $stmt 1 stephan
#set stmt [query_prepare $sql]
#query_bind_null $stmt 1
set rc 0
puts "USER LIST:\n"
catch {
    proc my_each {stmt colCount} {
        upvar 2 sep sep
        puts [query_col_int $stmt 0] " (type=" [query_col_type $stmt 0] ")" $sep
        puts [query_col_double $stmt 0] $sep
        puts [query_col_string $stmt 1]  " (type=" [query_col_type $stmt 1] ")" $sep
        puts "isnull 0 ?= " [query_col_is_null $stmt 0] $sep
        puts "isnull 2 ?= " [query_col_is_null $stmt 2]
#        for {set i 0} {$i < $colCount} {incr i} {
#            if {$i > 0} { puts $sep }
#        }
        puts "\n"
#        error "hi!"
    }
    query_step_each $stmt my_each
#    query_step_each $stmt {
#        proc each {stmt cc} { puts hi "\n" }
#    }
} rc
query_finalize $stmt
puts rc = $rc "\n"

set consts [list SQLITE_BLOB SQLITE_DONE SQLITE_ERROR SQLITE_FLOAT SQLITE_INTEGER SQLITE_NULL SQLITE_OK SQLITE_ROW SQLITE_TEXT]
#set consts $SQLITE_CONSTANTS
puts consts = $consts "\n"
for {set i 0} {$i < [llength $consts]} {incr i} {
    set x [lindex $consts $i]
    puts \$$x = [expr \$$x] "\n"
}

puts "If you got this far, you win!\n"
</th1>
